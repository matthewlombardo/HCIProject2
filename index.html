<!DOCTYPE html>
<html>
<head>
<!-- Add jquery to clear object -->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
<!-- Load d3.js -->
<script src="https://d3js.org/d3.v4.js"></script>
<script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
<script src="https://d3js.org/d3-geo-projection.v2.min.js"></script>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
/* @import url('https://fonts.googleapis.com/css2?family=Arvo&display=swap'); */
@import url('https://fonts.googleapis.com/css2?family=Bitter:wght@700&display=swap');
@import url('https://fonts.googleapis.com/css2?family=IBM+Plex+Sans&display=swap');

h1,h2 {
	font-family: 'Bitter', serif;
}

h3 {
	font-weight: normal;
	color: #334;
}

td {
  padding: 5px;
}

body {
	background-color: #EEE /* #FBFAED */;
	font-family: 'IBM Plex Sans', sans-serif;
}

.tooltip {
  z-index: 1070;
  display: block;
  margin: 0;
  /* font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol"; */
  font-style: normal;
  font-weight: 400;
  line-height: 1.5;
  text-align: left;
  text-align: start;
  text-decoration: none;
  text-shadow: none;
  text-transform: none;
  letter-spacing: normal;
  word-break: normal;
  word-spacing: normal;
  white-space: normal;
  line-break: auto;
  font-size: .875rem;
  word-wrap: break-word;
}

.dropbtn {
  background-color: #2980B9;
  color: white;
  padding: 12px;
  font-size: 12px;
  border: 1px;
  cursor: pointer;
}

.dropbtn:hover, .dropbtn:focus {
  background-color: #2980B9;
}

.dropdown {
  position: relative;
  display: inline-block;
}

.dropdown-content {
  display: none;
  position: absolute;
  background-color: #f1f1f1;
  min-width: 160px;
  overflow: auto;
  box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
  z-index: 1;
}

.dropdown-content a {
  color: black;
  padding: 12px 16px;
  text-decoration: none;
  display: block;
}

.dropdown a:hover {background-color: #ddd;}

.show {display: block;}

#wrapper {
	width: 960px;
	margin-left: auto;
	margin-right: auto;
}
</style>
<script>
  $(document).ready(function() {
  makeMap1('red')
  makeMap2('green')
  colorGraph1('race')
  colorGraph2('age')
  bubbler1('distance')
})
</script>

</head>

<body>
	<div id="wrapper">
<h1 style="text-align: center;">Examining Voting Inequality Through the 2020 Elections</h1>
<h3 style="text-align: center;">Team Members: Cindy Koo, Stephan Kemper, & Matthew Lombardo</h3>
<p>
  With the 2020 presidential elections fresh off in our minds, we thought this would be the perfect opportunity
  to dissect this monumental election and examine social injustice and accessibility issues through this project. According
  to the article “7 Signs Voter Suppression Could Be Happening Near You,” minority and low-income voters still face a 
  multitude of barriers in the voting process. While regulations have strived to provide equality and democracy to 
  everybody in casting a vote, new and subtle ways to prevent minority groups from practicing their rights. <!-- TODO finish sentence -->
</p>
<p>
  An article on the website Inequality, titled “Unleashing the Power of Poor Voters in a Black Milwaukee Neighborhood” found that roughly 16% 
  of Black voters in Milwaukee were “disenfranchised” from the Wisconsin primary due to the vast reduction of polling sites.
  Additionally, the campaigners highlighted in the article found that 34 million low-income individuals did not vote, 
  although they were eligible to. Another article on Inequality, titled “To Reduce Inequality in Elections, All States 
  Should Allow Voting at Home” offered a reason to why that is: because low-income citizens may experience more difficulties
  traveling to polling places. In this article, the authors vouch for voting at home for additional reasons, such as to 
  allow disabled people, seniors and rural voters to participate in the election. This got us interested in not only 
  conducting analyses on voter data, but also prompted us to think more about the accessibility issues in the election, 
  and how human-centered design principles can be implemented in future elections to reduce these problems.
</p>
<p>
  Inspired by the aforementioned articles, we set off on a quest to examine how voter inequality was prominent 
  in this recent election. We began with searching for voter registration databases online, and to our dismay, many states 
  requested payment in exchange for data. Fortunately for us, the state of North Carolina offered valuable data free of 
  charge. With a quick filling out of some forms, we were able to obtain a Voter Registration Database and a Voting History 
  Database. Thus, we decided to perform our data analysis on the wonderful state of North Carolina.
</p>


<!-- -->
<!-- MAPS -->
<!-- -->

<h2>Part I: Racial/Ethnic Background & Turnout Rate</h2>
<p>
  Next, we turned to examine the theme of racial background and turnout rate a little more closely. For this 
  analysis, we used a choropleth map, which is a data analysis method that shows different areas in the map in varying
   shades or colors that are proportional to a variable. We decided to include three variables that the user can choose
    to view for this visualization. In order to allow for ease of comparison between the variables, we included two maps
     side by side for easy access. The blank map divides North Carolina into its counties, as shown by 
     the borders. By clicking on different options above the map, the user can choose to view the map 
     according to the desired variable.
</p>
<p>
  Our data colors each county by one of several variables:
  <ul>
    <li>the percentage of individuals registered to vote, relative to the county's population</li>
    <li>the turnout rate for the election, relative to the number of registered voters</li>
    <li>the percentage of voters of each race.</li>
  </ul>
  Clicking on a variable redraws the map, with the different hues indicating varying degrees of the variable. For example, a white
  county would indicate zero percent, while a dark and vibrant color represents one hundred percent.
</p>
<p>

</p>

<div style="float:left" id="leftMap">
  <div class="dropdown">
    <button onclick="myFunction1()" class="dropbtn">Please select map!</button>
    <div id="myDropdown" class="dropdown-content">
      <a href="#home" onclick=makeMap1('red')>Red Map</a>
      <a href="#about" onclick=makeMap1('blue')>Blue Map</a>
      <a href="#contact" onclick=makeMap1('green')>Green Map</a>
    </div>
  </div>
<script>
function myFunction1() {
  document.getElementById("myDropdown").classList.toggle("show");
}

// Close the dropdown if the user clicks outside of it
window.onclick = function(event) {
  if (!event.target.matches('.dropbtn')) {
    var dropdowns = document.getElementsByClassName("dropdown-content");
    var i;
    for (i = 0; i < dropdowns.length; i++) {
      var openDropdown = dropdowns[i];
      if (openDropdown.classList.contains('show')) {
        openDropdown.classList.remove('show');
      }
    }
  }
}
</script>



<p></p>
<!-- Create an element where the map will take place -->

<svg id="my_dataviz" width="450" height="350"></svg>
<script>
function makeMap1(color) {
  // The svg
  var svg = d3.select("#my_dataviz")
  //var svg = d3.select("svg"),
    width = +svg.attr("width"),
    height = +svg.attr("height");

  // Map and projection
  var path = d3.geoPath();

  var projection = d3.geoMercator()
  	.scale(3700)
  	.center([-80,35])
    .translate([width / 2, height / 2]);

  // Data and color scale
  var data = d3.map();
  if (color=='red') {
  var colorScale = d3.scaleThreshold()
    .domain([100000, 1000000, 10000000, 30000000, 100000000, 500000000])
    .range(d3.schemeReds[7]);
  }


  // Load external data and boot
  var countyMap = new Map();
  var help;
  d3.queue()
    .defer(d3.json, "https://raw.githubusercontent.com/matthewlombardo/HCIProject2/master/nc.geojson")
    .defer(d3.csv, "https://raw.githubusercontent.com/matthewlombardo/HCIProject2/master/graph3TURNOUT.csv", (d) => {countyMap[d.COUNTY] = d.TURNOUT;})
	.await(ready);

	for (const [key, value] of countyMap.entries()) {
	  console.log("pair: ",  key, value);
	}

  function ready(error, topo) {

    // Draw the map
    svg.append("g")
      .selectAll("path")
      .data(topo.features)
      .enter()
      .append("path")
        // draw each country
        .attr("d", d3.geoPath()
          .projection(projection)
        )
        // set the color of each county
        .attr("fill", function (d) {
			console.log("let's see...", d.properties.NAME, countyMap[d.properties.NAME])
			console.log("testing!", countyMap["Wayne"])
          return colorScale(countyMap[d.properties.NAME]);
        })
      }

}
</script>
</div>

<div style="float:right" id="rightMap">
  <div class="dropdown">
    <button onclick="myFunction2()" class="dropbtn">Please select map!</button>
    <div id="myDropdown2" class="dropdown-content">
      <a href="#home" onclick=makeMap2('red')>Red Map 2</a>
      <a href="#about" onclick=makeMap2('blue')>Blue Map 2</a>
      <a href="#contact" onclick=makeMap2('green')>Green Map 2</a>
    </div>
  </div>
<script>
function myFunction2() {
  document.getElementById("myDropdown2").classList.toggle("show");
}

</script>
<p></p>

<svg id="my_dataviz2" width="450" height="350"></svg>
<script>
function makeMap2(color) {

  // The svg
  var svg = d3.select("#my_dataviz2")
  //var svg2 = d3.select("svg2"),
    width = +svg.attr("width"),
    height = +svg.attr("height");

  // Map and projection
  var path = d3.geoPath();
  var projection = d3.geoMercator()
    .scale(70)
    .center([0,20])
    .translate([width / 2, height / 2]);

  // Data and color scale
  var data = d3.map();
  if (color=='red') {
  var colorScale = d3.scaleThreshold()
    .domain([100000, 1000000, 10000000, 30000000, 100000000, 500000000])
    .range(d3.schemeReds[7]);
    }
    else if (color=='blue') {
    var colorScale = d3.scaleThreshold()
    .domain([100000, 1000000, 10000000, 30000000, 100000000, 500000000])
    .range(d3.schemeBlues[7]);
    }
    else if (color=='green') {
    var colorScale = d3.scaleThreshold()
    .domain([100000, 1000000, 10000000, 30000000, 100000000, 500000000])
    .range(d3.schemeGreens[7]);
    }


  // Load external data and boot
  d3.queue()
    .defer(d3.json, "https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/world.geojson")
    .defer(d3.csv, "https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/world_population.csv", function(d) { data.set(d.code, +d.pop); })
    .await(ready);


  function ready(error, topo) {

    // Draw the map
    svg.append("g")
      .selectAll("path")
      .data(topo.features)
      .enter()
      .append("path")
        // draw each country
        .attr("d", d3.geoPath()
          .projection(projection)
        )
        // set the color of each country
        .attr("fill", function (d) {
			console.log("properties?", d.properties)
          d.total = data.get(d.id) || 0;
		  console.log("data.get(d.id)",data.get(d.id))
		  console.log("d.total",d.total)

          return colorScale(d.total);
        })
      }

}
</script>
</div>

<hr style="clear:both;">


<p><!-- Blank so button formats correctly --> </p>

<!-- -->
<!-- BAR GRAPHS -->
<!-- -->

<h2>Part II: Voting History & Demographic Information</h2>
<p>
  We began our analysis with the topic of voter demographic information and voter's registered party for the 2020 
  General Election in North Carolina. With findings from articles that state the discrepancies in voter turnout rates between different 
  demographic groups, we were interested to see if this applied to North Carolina too.
</p>
<p>
  We chose three demographic variables (age, gender, and race) and compared the number of voters in each of the 
  sub-categories of a variable. For reference, and to make the data even more interesting, we included data 
  regarding registered political party.  In order for ease of comparison between the categories, we used a stacked 
  bar graph that allows for quick comprehension of the data. 
</p>
<p>
  What we found in relation to age groups was a significant clustering of high votes between the ages of 20 to 60.
  In contrast, we see the numbers drop for individuals in their 70s and 80s.  While we might explain that away with the 
  fact that here are many fewer of these voters, we also observe low numbers of votes for individuals in their early adulthood.
  These low numbers could be due to a number of factors, such as inaccessibility to transportation to polling booths, 
  education levels, and difficulty in voter registration.
</p>
<p>
  In terms of voter sex and turnout rate, we didn’t find much that was surprising, as there seemed 
  to be a smaller margin of difference for the total votes between the male and female voters. What intrigued us most 
  was the data on race and voter turnout rates. The race of the voters is indicated on the X-axis of the plot; the key is 
  below. There is a huge difference between the amount of White and Black voters. Even taking into account the general 
  race demographics of North Carolina (reported to be 63% White and 21% Black), we can observe a 
  drastically low turnout rate for Black voters.
</p>

<div id="barGraphKey" style="clear: both; width: 500px; margin-left: auto; margin-right: auto;">
  <h3>Table Legends</h3>
  <table style="float: left; top: 30px; left: 0px; border: none; font-size: .8em; width: 200px;">
    <tr>
      <td>W</td>
      <td>White</td>
    </tr>
    <tr>
      <td>B</td>
      <td>Black or African American</td>
    </tr>
    <tr>
      <td>A</td>
      <td>Asian</td>
    </tr>
    <tr>
      <td>IA/AN</td>
      <td>Indian American or Alaska Native</td>
    </tr>
    <tr>
      <td>U</td>
      <td>Undesignated</td>
    </tr>
    <tr>
      <td>2+</td>
      <td>Two or More Races</td>
    </tr>
    <tr>
      <td>O</td>
      <td>Other</td>
    </tr>
    <tr>
      <td>NH/PI</td>
      <td>Native Hawaiian or Pacific Islander</td>
    </tr>
  </table>
  <table style="float: right; border: none; font-size: .8em; width: 200px; margin-left: 40px;">
    <tr>
      <td>Red</td>
      <td>Republican</td>
    </tr>
    <tr>
      <td>Blue</td>
      <td>Democratic</td>
    </tr>
    <tr>
      <td>Green</td>
      <td>Libertarian</td>
    </tr>
    <tr>
      <td>Orange</td>
      <td>Unaffiliated</td>
    </tr>
    <tr>
      <td>Yellow</td>
      <td>Constitution</td>
    </tr>
    <tr>
      <td>Black</td>
      <td>Green</td>
    </tr>
  </table>
</div>

<div style="float:left; clear: both">
<div class="dropdown">
  <button onclick="myFunction3()" class="dropbtn">Please select demographic:</button>
  <div id="myDropdown3" class="dropdown-content">
    <a href="#home" onclick=colorGraph1('age')>Age Group</a>
    <a href="#about" onclick=colorGraph1('sex')>Sex</a>
    <a href="#contact" onclick=colorGraph1('race')>Race</a>
  </div>
</div>
<script>
function myFunction3() {
  document.getElementById("myDropdown3").classList.toggle("show");
}
</script>
<p> <!--blank line to put button on top --> </p>


<!-- Create a div where the graph will take place -->
<svg id="my_dataviz3" width="450" height="400"></svg>
<script>
function colorGraph1(demographic) {

// set the dimensions and margins of the graph
var margin = {top: 10, right: 30, bottom: 20, left: 50},
    width = 460 - margin.left - margin.right,
    height = 400 - margin.top - margin.bottom;

// append the svg object to the body of the page
$("#my_dataviz3").empty();
var svg = d3.select("#my_dataviz3")
  .append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform",
          "translate(" + margin.left + "," + margin.top + ")");


// Parse the Data
var urls = ["https://raw.githubusercontent.com/matthewlombardo/HCIProject2/master/graph1AGE.csv","https://raw.githubusercontent.com/matthewlombardo/HCIProject2/master/graph1SEX.csv","https://raw.githubusercontent.com/matthewlombardo/HCIProject2/master/graph1RACE.csv"];
var filename;
if (demographic=='age') {
	filename = urls[0];
}
else if (demographic=='sex'){
	filename = urls[1];
}
else if (demographic=='race'){
	filename = urls[2];
}

d3.csv(filename, function(data) {

  // List of subgroups = header of the csv files = soil condition here
  var subgroups = data.columns.slice(1)
  console.log(subgroups)

  // List of groups = species here = value of the first column called group -> I show them on the X axis
  var groups;
  var domain;
  if (demographic=='age') {
	  groups = d3.map(data, function(d){return(d.AGEGROUP)}).keys()
	  domain = 1000000;
  }
  else if (demographic=='sex'){
	  groups = d3.map(data, function(d){return(d.SEX)}).keys()
	  domain = 2500000;
  }
  else if (demographic=='race'){
	  groups = d3.map(data, function(d){return(d.RACE)}).keys()
	  domain = 3500000;
  }
  //var groups = d3.map(data, function(d){return(d.AGEGROUP)}).keys()
  //console.log(groups)

  // Add X axis
  var x = d3.scaleBand()
      .domain(groups)
      .range([0, width+20])
      .padding([0.2])
  svg.append("g")
    .attr("transform", "translate(0," + height + ")")
    .call(d3.axisBottom(x).tickSizeOuter(0));

  //
  // Add Y axis
  var y = d3.scaleLinear()
    .domain([0, domain])
    .range([ height, 0 ]);
  svg.append("g")
    .call(d3.axisLeft(y));

	var color = d3.scaleOrdinal()
	  .domain(subgroups)
	  .range(['red','blue','green','orange','yellow','black'])


  //stack the data? --> stack per subgroup
  var stackedData = d3.stack()
    .keys(subgroups)
    (data)

  // Show the bars
  if (demographic=='age') {
	  svg.append("g")
	    .selectAll("g")
	    // Enter in the stack data = loop key per key = group per group
	    .data(stackedData)
	    .enter().append("g")
	      .attr("fill", function(d) { return color(d.key); })
	      .selectAll("rect")
	      // enter a second time = loop subgroup per subgroup to add all rectangles
	      .data(function(d) { return d; })
	      .enter().append("rect")
	        .attr("x", function(d) { return x(d.data.AGEGROUP); })
	        .attr("y", function(d) { return y(d[1]); })
	        .attr("height", function(d) { return y(d[0]) - y(d[1]); })
	        .attr("width",x.bandwidth())
	}
	else if (demographic=='sex') {
  	  svg.append("g")
  	    .selectAll("g")
  	    // Enter in the stack data = loop key per key = group per group
  	    .data(stackedData)
  	    .enter().append("g")
  	      .attr("fill", function(d) { return color(d.key); })
  	      .selectAll("rect")
  	      // enter a second time = loop subgroup per subgroup to add all rectangles
  	      .data(function(d) { return d; })
  	      .enter().append("rect")
  	        .attr("x", function(d) { return x(d.data.SEX); })
  	        .attr("y", function(d) { return y(d[1]); })
  	        .attr("height", function(d) { return y(d[0]) - y(d[1]); })
  	        .attr("width",x.bandwidth())
  	}
	else  if (demographic=='race') {
  	  svg.append("g")
  	    .selectAll("g")
  	    // Enter in the stack data = loop key per key = group per group
  	    .data(stackedData)
  	    .enter().append("g")
  	      .attr("fill", function(d) { return color(d.key); })
  	      .selectAll("rect")
  	      // enter a second time = loop subgroup per subgroup to add all rectangles
  	      .data(function(d) { return d; })
  	      .enter().append("rect")
  	        .attr("x", function(d) { return x(d.data.RACE); })
  	        .attr("y", function(d) { return y(d[1]); })
  	        .attr("height", function(d) { return y(d[0]) - y(d[1]); })
  	        .attr("width",x.bandwidth())
  	}

})
}
</script>
</div>

<div style="float:right">
<div class="dropdown">
  <button onclick="myFunction4()" class="dropbtn">Please select demographic:</button>
  <div id="myDropdown4" class="dropdown-content">
    <a href="#" onclick=colorGraph2('age')>Age Group</a>
    <a href="#" onclick=colorGraph2('sex')>Sex</a>
    <a href="#" onclick=colorGraph2('race')>Race</a>
  </div>
</div>
<script>
function myFunction4() {
  document.getElementById("myDropdown4").classList.toggle("show");
}
</script>
<p> <!--blank line to put button on top --> </p>

<!-- Create a div where the graph will take place -->
<svg id="my_dataviz4" width="450" height="400"></svg>
<script>
function colorGraph2(demographic) {

// set the dimensions and margins of the graph
var margin = {top: 10, right: 30, bottom: 20, left: 50},
    width = 460 - margin.left - margin.right,
    height = 400 - margin.top - margin.bottom;

// append the svg object to the body of the page
$("#my_dataviz4").empty();
var svg = d3.select("#my_dataviz4")
  .append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform",
          "translate(" + margin.left + "," + margin.top + ")");


// Parse the Data
var urls = ["https://raw.githubusercontent.com/matthewlombardo/HCIProject2/master/graph1AGE.csv","https://raw.githubusercontent.com/matthewlombardo/HCIProject2/master/graph1SEX.csv","https://raw.githubusercontent.com/matthewlombardo/HCIProject2/master/graph1RACE.csv"];
var filename;
if (demographic=='age') {
	filename = urls[0];
}
else if (demographic=='sex'){
	filename = urls[1];
}
else if (demographic=='race'){
	filename = urls[2];
}

d3.csv(filename, function(data) {

  // List of subgroups = header of the csv files = soil condition here
  var subgroups = data.columns.slice(1)
  console.log(subgroups)

  // List of groups = species here = value of the first column called group -> I show them on the X axis
  var groups;
  var domain;
  if (demographic=='age') {
	  groups = d3.map(data, function(d){return(d.AGEGROUP)}).keys()
	  domain = 1000000;
  }
  else if (demographic=='sex'){
	  groups = d3.map(data, function(d){return(d.SEX)}).keys()
	  domain = 2500000;
  }
  else if (demographic=='race'){
	  groups = d3.map(data, function(d){return(d.RACE)}).keys()
	  domain = 3500000;
  }
  //var groups = d3.map(data, function(d){return(d.AGEGROUP)}).keys()
  //console.log(groups)

  // Add X axis
  var x = d3.scaleBand()
      .domain(groups)
      .range([0, width+20])
      .padding([0.2])
  svg.append("g")
    .attr("transform", "translate(0," + height + ")")
    .call(d3.axisBottom(x).tickSizeOuter(0));

  //
  // Add Y axis
  var y = d3.scaleLinear()
    .domain([0, domain])
    .range([ height, 0 ]);
  svg.append("g")
    .call(d3.axisLeft(y));

	var color = d3.scaleOrdinal()
	  .domain(subgroups)
	  .range(['red','blue','green','orange','yellow','black'])


  //stack the data? --> stack per subgroup
  var stackedData = d3.stack()
    .keys(subgroups)
    (data)

  // Show the bars
  if (demographic=='age') {
	  svg.append("g")
	    .selectAll("g")
	    // Enter in the stack data = loop key per key = group per group
	    .data(stackedData)
	    .enter().append("g")
	      .attr("fill", function(d) { return color(d.key); })
	      .selectAll("rect")
	      // enter a second time = loop subgroup per subgroup to add all rectangles
	      .data(function(d) { return d; })
	      .enter().append("rect")
	        .attr("x", function(d) { return x(d.data.AGEGROUP); })
	        .attr("y", function(d) { return y(d[1]); })
	        .attr("height", function(d) { return y(d[0]) - y(d[1]); })
	        .attr("width",x.bandwidth())
	}
	else if (demographic=='sex') {
  	  svg.append("g")
  	    .selectAll("g")
  	    // Enter in the stack data = loop key per key = group per group
  	    .data(stackedData)
  	    .enter().append("g")
  	      .attr("fill", function(d) { return color(d.key); })
  	      .selectAll("rect")
  	      // enter a second time = loop subgroup per subgroup to add all rectangles
  	      .data(function(d) { return d; })
  	      .enter().append("rect")
  	        .attr("x", function(d) { return x(d.data.SEX); })
  	        .attr("y", function(d) { return y(d[1]); })
  	        .attr("height", function(d) { return y(d[0]) - y(d[1]); })
  	        .attr("width",x.bandwidth())
  	}
	else  if (demographic=='race') {
  	  svg.append("g")
  	    .selectAll("g")
  	    // Enter in the stack data = loop key per key = group per group
  	    .data(stackedData)
  	    .enter().append("g")
  	      .attr("fill", function(d) { return color(d.key); })
  	      .selectAll("rect")
  	      // enter a second time = loop subgroup per subgroup to add all rectangles
  	      .data(function(d) { return d; })
  	      .enter().append("rect")
  	        .attr("x", function(d) { return x(d.data.RACE); })
  	        .attr("y", function(d) { return y(d[1]); })
  	        .attr("height", function(d) { return y(d[0]) - y(d[1]); })
  	        .attr("width",x.bandwidth())
  	}

})
}
</script>
</div>


<hr style="clear:both;">

<!-- -->
<!-- BUBBLES -->
<!-- -->


<h2>Part III: Distance to Polling Places</h2>
<p>
  Finally, we conducted a spatial analysis on distance to polling places. Through the voter registration database, 
  we obtained the addresses of each voter in North Carolina, and through the polling locations database, we retrieved the 
  locations of all polling booths across the counties.  We could then geocode those locations into latitude and longitude,
  and calculate the distance between a voter's home and their polling center.
</p>
<p>
  As we found during our analysis, there are significant problems with the quality of this data.  Using open source 
  methods and data sets, we could only successfully geocode roughly two-thirds of total voters in the state.  Many
  voters had addresses that were incomplete or did not match with geospatial data sets from other agencies, such
  as the US Census Bureau.  Even some polling places had addresses that were incorrect or incomplete.  The first
  class of data problems might lead voters to be denied their vote, because their registration is incomplete or invalid.
  The third may end up sending voters to the wrong location, or stop them from going out to vote altogether.
</p>
<p>
  This analysis was conducted in order to expand on some themes we introduced earlier: accessibility to polling booths
  and its effect on ease of voting. For this visualization, we utilized a bubble chart, in which the area of each bubble
  is proportional to a value; in this case, the average distance to polling places or voter turnout rate in each county.
</p>
<p>
  <!-- Insert analysis here after bubbles are done -->
</p>

<!-- Bubble Chart -->
<div id="bubbleCharts">
<div class="dropdown">
  <button onclick="myFunction5()" class="dropbtn">Please select statistic:</button>
  <div id="myDropdown5" class="dropdown-content">
    <a href="#home" onclick=bubbler1('distance')>Average Distance to Polling Place</a>
    <a href="#about" onclick=bubbler1('voter')>Voter Turnout</a>
  </div>
</div>


<!-- Instantiate svg object -->
<style>
.node:hover{
  stroke-width: 7px !important;
  opacity: 1 !important;
}
</style>

<script>
function myFunction5() {
  document.getElementById("myDropdown5").classList.toggle("show");
}
</script>

<p><!-- blank line to put button on top --> </p>
<div id="my_dataviz5" width="400" height="400"></div>

<script>
function bubbler1(scheme) {
	// set the dimensions and margins of the graph
	var width = 460
	var height = 460

	// append the svg object to the body of the page
	$("#my_dataviz5").empty();
	var svg = d3.select("#my_dataviz5")
	  .append("svg")
	    .attr("width", width)
	    .attr("height", height)

	// Read data
	d3.csv("https://raw.githubusercontent.com/matthewlombardo/HCIProject2/master/graph3TURNOUT.csv", function(data) {

	  // Size scale for countries
	  var size = d3.scaleLinear()
	    .domain([0, 1000])
	    .range([7,100])  // circle will be between 7 and 55 px wide

	  // create a tooltip
	  var Tooltip = d3.select("#my_dataviz5")
	    .append("div")
	    .style("opacity", 0)
	    .attr("class", "tooltip")
	    .style("background-color", "white")
	    .style("border", "solid")
	    .style("border-width", "2px")
	    .style("border-radius", "5px")
	    .style("padding", "5px")
      .style("height", "100px")
      .style("width", "100px")

	  // Three function that change the tooltip when user hover / move / leave a cell
	  var mouseover = function(d) {
    	Tooltip.style("opacity", 1)
  	  }
	  /* @STEPHAN:
	  This mousemove function should be displaying that print output.
	  It prints to the console, like if you look at the div in the source in
	 a browser it will show u, but it won't print on the screen.

	 This code came from https://www.d3-graph-gallery.com/graph/circularpacking_template.html,
	 where it works.
	 */
	  var mousemove = function(d) {
	   	Tooltip
	      .html('<u>' + d.COUNTY + '</u>' + "<br>" + d.TURNOUT + " inhabitants")
	      .style("left", (d3.mouse(this)[0]+20) + "px")
	      .style("top", (d3.mouse(this)[1]) + "px")
	  }
	  var mouseleave = function(d) {
	    Tooltip
	      .style("opacity", 0)
	  }

	  // Select color for party.
	  function color(party) {
		  if (party=='R') {
			  return "red";
		  }
		  else if (party=='D') {
			  return "blue";
		  }
	  }
	  // Initialize the circle: all located at the center of the svg area
	  var node = svg.append("g")
	    .selectAll("circle")
	    .data(data)
	    .enter()
	    .append("circle")
	      .attr("class", "node")
	      .attr("r", function(d){ return size(d.TURNOUT)})
	      .attr("cx", width / 2)
	      .attr("cy", height / 2)
	      .style("fill", function(d){ return color(d.PARTY)})
	      .style("fill-opacity", 0.8)
	      .attr("stroke", "black")
	      .style("stroke-width", 1)
	      .on("mouseover", mouseover) // What to do when hovered
	      .on("mousemove", mousemove)
	      .on("mouseleave", mouseleave)

	  // Features of the forces applied to the nodes:
	  var simulation = d3.forceSimulation()
	      .force("center", d3.forceCenter().x(width / 2).y(height / 2)) // Attraction to the center of the svg area
	      .force("charge", d3.forceManyBody().strength(-1)) // Nodes are attracted one each other of value is > 0
	      .force("collide", d3.forceCollide().strength(1).radius(function(d){ return (size(d.value)+3) }).iterations(1)) // Force that avoids circle overlapping

	  // Apply these forces to the nodes and update their positions.
	  // Once the force algorithm is happy with positions ('alpha' value is low enough), simulations will stop.
	  simulation
	      .nodes(data)
	      .on("tick", function(d){
	        node
	            .attr("cx", function(d){ return d.x; })
	            .attr("cy", function(d){ return d.y; })
	      });


	})
}
</script>
</div>

<div style="float:right">
	<p> Some analysis....</p>
</div>

<hr style="clear:both;">

<h2>Epilogue</h2>
<p>
  Through this project, we had the fascinating experience of examining social injustice and accessibility issues in the scope of elections.
  The current analysis just scratches the surface, and prompts us to ask questions for further study.
</p>
<p><span style="font-weight: bold">How are individuals in various groups that we haven’t explore (socioeconomic, educational) affected by 
  voting accessibility?</span> <!-- MORE -->
</p>
<p><span style="font-weight: bold">How would other states look different from North Carolina?</span><!-- MORE -->
</p>
<p><span style="font-weight: bold">Are there correllations between political bents and voter inequality?</span>
</p>
<p>
  Answering any one of these questions is complex.  Even harder is proposing solutions to combat and ameliorate these issues so that 
  future elections aren’t tainted by the same problems that are prevalent now.  This project gave us an excellent opportunity to 
  become more educated about social injustice issues revolving the election, how marginalized populations are affected, and what 
  consequences these issues can pose. With this insight, we hope to be more cognizant and considerate in our designing practices 
  going forward. 
</p>

<hr style="clear: both;">


<h2>References</h2>

We borrowed d3.js code from the following sources:

<ul>
  <li>Part I: <a href="https://www.d3-graph-gallery.com/graph/choropleth_basic.html">https://www.d3-graph-gallery.com/graph/choropleth_basic.html</a></li>
  <li>Part II: <a href="https://www.d3-graph-gallery.com/graph/barplot_stacked_basicWide.html">https://www.d3-graph-gallery.com/graph/barplot_stacked_basicWide.html</a></li>
  <li>Part III: <a href="https://www.d3-graph-gallery.com/graph/circularpacking_template.html">https://www.d3-graph-gallery.com/graph/circularpacking_template.html</a></li>
</ul>

Additionally, the following resources contributed insight:

<ul>
  <li><a href="https://www.dosomething.org/us/articles/7-signs-voter-suppression-could-be-happening-near-you">https://www.dosomething.org/us/articles/7-signs-voter-suppression-could-be-happening-near-you</a></li>
  <li><a href="https://inequality.org/great-divide/vote-at-home/">https://inequality.org/great-divide/vote-at-home/</a></li>
  <li><a href="https://inequality.org/great-divide/unleashing-the-power-of-poor-voters-in-a-black-milwaukee-neighborhood/">https://inequality.org/great-divide/unleashing-the-power-of-poor-voters-in-a-black-milwaukee-neighborhood/</a></li>
</ul>

Code used for this project is available in the following repositories:

<ul>
  <li><a href="https://github.com/skemper/hcip2">Data analysis code</a></li>
  <li><a href="https://github.com/matthewlombardo/HCIProject2">Code for this website</a></li>
</ul>

Finally, our underlying data comes from:

<ul>
  <li><a href="https://demography.osbm.nc.gov/explore/dataset/ncprojectionsbyagegrp2019/table/">North Carolina State Demographer: Population Projections by Race, Sex & Age Groups</a></li>
  <li><a href="https://download.geofabrik.de/north-america/us.html">GeoFabrik US data file</a></li>
  <li><a href="https://nominatim.org/">Nominatim Geocoding</a></li>
  <li><a href="https://vt.ncsbe.gov/pplkup/">North Carolina Polline Place Lookup</a></li>
  <li><a href="https://www.ncsbe.gov/results-data/voter-history-data">North Carolina Voter History Data</a></li>
  <li><a href="https://www.ncsbe.gov/results-data/voter-registration-data">North Carolina Voter Registration Data</a></li>
</ul>

</div>
</body>


</html>
